package minimal

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
)

// ProblemDetails is the struct definition of a problem details object
type ProblemDetails struct {
	// Type is a URI reference [RFC3986] that identifies the
	// problem type. This specification encourages that, when
	// dereferenced, it provide human-readable documentation for the
	// problem type (e.g., using HTML [W3C.REC-html5-20141028]).  When
	// this member is not present, its value is assumed to be
	// "about:blank".
	Type string `json:"type"`
	// Title is a short, human-readable summary of the problem
	// type.  It SHOULD NOT change from occurrence to occurrence of the
	// problem, except for purposes of localization (e.g., using
	// proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title"`
	// Status is the HTTP status code ([RFC7231], Section 6)
	// generated by the origin server for this occurrence of the problem.
	Status int `json:"status,omitempty"`
	// Detail is a human-readable explanation specific to this
	// occurrence of the problem.
	// If present, it ought to focus on helping the client
	// correct the problem, rather than giving debugging information.
	Detail string `json:"detail,omitempty"`
	// Instance is a URI reference that identifies the specific
	// occurrence of the problem.  It may or may not yield further
	// information if dereferenced.
	Instance string `json:"instance,omitempty"`
	// Params are request input field level errors. They communicate
	// back to client hints as to the exact problem.
	Params map[string]string `json:"params,omitempty"`
}

// Error implements the error interface
func (pd *ProblemDetails) Error() string {
	if pd.Title == "" && pd.Detail == "" {
		return fmt.Sprintf("Status %d", pd.Status)
	}

	if pd.Detail == "" {
		return fmt.Sprintf("%s", pd.Title)
	}
	return fmt.Sprintf("%s: %s", pd.Title, pd.Detail)
}

// Problem creates a new ProblemDetails error
func Problem(statusCode int, problemType, title, detail, instance string, params map[string]string) *ProblemDetails {
	// When this member is not present, its value is assumed to be
	// "about:blank".
	if problemType == "" {
		problemType = "about:blank"
	}

	// When "about:blank" is used, the title SHOULD be the same as the
	// recommended HTTP status phrase for that code (e.g., "Not Found" for
	// 404, and so on), although it MAY be localized to suit client
	// preferences (expressed with the Accept-Language request header).
	if problemType == "about:blank" {
		title = http.StatusText(statusCode)
	}

	return &ProblemDetails{
		Type:     problemType,
		Title:    title,
		Status:   statusCode,
		Detail:   detail,
		Instance: instance,
		Params:   params,
	}
}

// ProblemStatus creates a new ProblemDetails error based just on the HTTP Status Code
func ProblemStatus(statusCode int) *ProblemDetails {
	return Problem(statusCode, "", "", "", "", nil)
}

func ProblemUnexpected(err error) *ProblemDetails {
	return Problem(http.StatusInternalServerError, "unexpected", "Unexpected problem",
		err.Error(), "", nil)
}

func ProblemNotFound() *ProblemDetails {
	return Problem(http.StatusNotFound, "not-found", "Record not found",
		"", "", nil)
}

func ProblemPermit(username string) *ProblemDetails {
	detail := fmt.Sprintf("%s does not have proper permissions", username)
	return Problem(http.StatusForbidden, "not-permitted", "User not permitted",
		detail, "", nil)
}

func ProblemValid(params map[string]string) *ProblemDetails {
	return Problem(http.StatusBadRequest, "validation-failed", "Validation failed",
		"Fix the errors and try again", "", params)
}

func ProblemRule(rule string) *ProblemDetails {
	return Problem(http.StatusBadRequest, "rule failure", "Rule failure",
		rule, "", nil)
}

func ProblemOld() *ProblemDetails {
	return Problem(http.StatusConflict, "not-current", "Record not current",
		"Reload and try again", "", nil)
}

func (pd *ProblemDetails) enrich(ctx context.Context, config *Config) {
	if config.ProblemTypeUrlFormat != "" && pd.Type != "about:blank" {
		pd.Type = fmt.Sprintf(config.ProblemTypeUrlFormat, pd.Type)
	}

	if config.ProblemInstanceFunc != nil {
		pd.Instance = config.ProblemInstanceFunc(ctx)
	}
}

// ServeJSON will output Problem Details json to the response writer
func (pd *ProblemDetails) serveJSON(w http.ResponseWriter, r *http.Request) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(pd.Status)
	if err := json.NewEncoder(w).Encode(pd); err != nil {
		return err
	}
	return nil
}
